#!/usr/bin/env bash
# for doc, see md file

set -Eeuo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"

# Bash lib library path detection
if [ "${BASHLIB_PATH:-}" == "" ]; then
  BASHLIB_PATH="$SCRIPT_DIR/../lib"
fi
export PATH="$BASHLIB_PATH:$PATH"

# shellcheck source=../..//bash-lib/lib/bashlib-error.sh
source "bashlib-error.sh"
error::set_trap
# shellcheck source=../..//bash-lib/lib/bashlib-doc.sh
source "bashlib-doc.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-string.sh
source "bashlib-command.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-git.sh
source "bashlib-git.sh"

function synopsis() {

  cat << EOF
Recreate the last commit with the actual modified and added files.
\`\`\`bash
$(basename "$0")  [Commit Message]
\`\`\`
If the commit message is not given, it will take the message of the last commit.
EOF
}

# Doc Synopsis
if [ "${1:-}" = "synopsis" ]; then
  synopsis
  exit 0
fi

# Help
if [[ "${1:-}" =~ -h|--help|help ]]; then
  doc::help synopsis
  exit 0
fi

# First submodule
# Not in a submodule (.git is a file)
if [ ! -f .git ]; then
  # script dir is mandatory because we may call the next version
  # and git-amend in the path is generally the actual version
  git submodule foreach "$SCRIPT_DIR/git-amend"
fi

# Args parsing
COMMIT_MESSAGE=""
MESSAGE_EDIT=false
while [[ $# -gt 0 ]]; do
  case "$1" in
    -e | --edit)
      MESSAGE_EDIT=true
      ;;
    *)
      COMMIT_MESSAGE=${1}
      shift
      break
      ;;
  esac
  shift
done

if ! git::is_dirty_index && [ "$COMMIT_MESSAGE" == "" ] && [ $MESSAGE_EDIT == false ]; then
  echo::warn "Nothing to do: no files to amend, no message to edit, no new message, exiting"
  # if this is not a submodule, error
  if [ ! -f .git ]; then
    echo::err "Not a submodule, error"
    exit 1
  fi
  exit 0
fi

# Default Message
if [ "$COMMIT_MESSAGE" == "" ]; then
  COMMIT_MESSAGE=$(git log -1 --pretty=%B)
fi

# Get the last commit hash
last_commit=$(git rev-parse HEAD)
tags=$(git tag --points-at "$last_commit")
if [ "$tags" != "" ]; then
  echo "Tags found on the last commit, deleting them"
  git-tag-delete "$tags"
fi

# Check the actual files before the undo (delete of the last commit)
# If there is an error in the actual files, the commit command will fail
# and the user don't know where he is (ie is the commit deleted ???)
# With this check, the user can run this command until no error occurs and be sure that
# there was only one undo
# By checking the file first, git-backup will not fail
# knowing that it will not delete another commit
command::echo_eval "git-prepare"
# delete the last commit
command::echo_eval "git-undo"
# commit after / no verify to disable git-hooks has we have done it earlier with git-prepare
echo "Commit"
COMMIT_ARGS=(commit --no-verify -am "$COMMIT_MESSAGE")
if [ $MESSAGE_EDIT == true ]; then
  COMMIT_ARGS+=(--edit)
fi
# we can't do a echo eval because the commit message may be on multiple lines
git "${COMMIT_ARGS[@]}"
# push
command::echo_eval "git push"
