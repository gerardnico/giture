#!/usr/bin/env bash
# for docs, see md file

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"

# Bash lib library path detection
if [ "${BASHLIB_PATH:-}" == "" ]; then
  # This is also a valid path for brew
  BASHLIB_PATH="$SCRIPT_DIR/../lib"
fi
export PATH="$BASHLIB_PATH:$PATH"

# shellcheck source=../..//bash-lib/lib/bashlib-error.sh
source "bashlib-error.sh"
error::set_strict_mode
error::set_trap
# shellcheck source=../..//bash-lib/lib/bashlib-echo.sh
source "bashlib-echo.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-git.sh
source "bashlib-git.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-command.sh
source "bashlib-command.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-path.sh
source "bashlib-path.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-doc.sh
source "bashlib-doc.sh"

function synopsis() {

  cat << EOF
List, switch to or create a branch
\`\`\`bash
$(basename "$0") [options] [branch_name]
\`\`\`

  Options:
    * \`-nr\` or \`--no-recurse\` to not recurse in submodule

  Args:
    * without branch name, the local and remotes branches are listed
    * with a branch name
      * the branch is created if it does not exist
      * the work is stashed
      * the working branch is changed
      * the optional stashed work is popped
EOF

}

RECURSE=true
BRANCH_NAME=""
ORIGINAL_ARGS=("$@")
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help | help)
      # Help
      doc::help synopsis
      exit 0
      ;;
    synopsis)
      # Doc Synopsis
      synopsis
      exit 0
      ;;
    -nr | --no-recurse)
      RECURSE=false
      ;;
    *)
      BRANCH_NAME=${1}
      shift
      break
      ;;
  esac
  shift
done

# First submodules
# If not in a submodule (in a submodule .git is a file)
# Otherwise the commit is only for the submodule
if [ $RECURSE == true ] && [ ! -f .git ]; then

  # script dir is mandatory because we may call the next version
  # and the git-xxxx command in the PATH env var is generally the actual version
  CMD="$SCRIPT_DIR/$(basename "$0")"
  # Quote the arguments otherwise you get space in message
  for ORIGINAL_ARG in "${ORIGINAL_ARGS[@]}"; do
    CMD+=" \"$ORIGINAL_ARG\""
  done
  if ! git submodule foreach "$CMD"; then
    echo::err "Error when executing $(basename "$0") to a submodule. Command: $CMD"
    exit 1
  fi

fi

# Status of the actual repo
if [ ! -f .git ]; then
  echo ""
  echo "Entering main repo"
fi

if [ "$BRANCH_NAME" = "" ]; then
  echo "list remote and local branch"
  git branch --all --column=never
  exit 0
fi

# Nothing to commit but push
DIRTY_INDEX=false
if git::is_dirty_index; then
  DIRTY_INDEX=true
fi
if [ $DIRTY_INDEX == true ]; then
  echo::info "Index is dirty, saving in stash"
  git stash
fi

if ! git::branch_exists "$BRANCH_NAME"; then
  echo::info "Creating branch $BRANCH_NAME"
  git branch "$BRANCH_NAME"
fi

echo::info "Switching to the branch $BRANCH_NAME"
git checkout "$BRANCH_NAME"

if [ $DIRTY_INDEX == "yes" ]; then
  echo::info "Index was dirty, popping the stash"
  git stash pop
fi

echo::success "Switched to the branch $BRANCH_NAME"
