#!/usr/bin/env bash
# Create and add a commit to the log
# If you don't want to create a commit, uses git-backup
# It will add the actual working files in the last commit

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"

# Bash lib library path detection
if [ "${BASHLIB_PATH:-}" == "" ]; then
  BASHLIB_PATH="$SCRIPT_DIR/../lib"
fi
export PATH="$BASHLIB_PATH:$PATH"

# shellcheck source=../..//bash-lib/lib/bashlib-error.sh
source "bashlib-error.sh"
error::set_strict_mode
error::set_trap
# shellcheck source=../..//bash-lib/lib/bashlib-echo.sh
source "bashlib-echo.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-git.sh
source "bashlib-git.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-command.sh
source "bashlib-command.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-path.sh
source "bashlib-path.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-doc.sh
source "bashlib-doc.sh"

function synopsis() {

  cat << EOF
\`\`\`bash
$(basename "$0") [Options] [Optional Commit Message]
\`\`\`
  * Args:
    * if the commit message is not given, it will be generated with the files in the commit.

  * Options:
    * \`--edit\` or \`-e\`          : edit the message in the editor
    * \`--no-recurse\` or \`-nr\`   : don't recurse and commit in the submodules
EOF

}

# Doc Synopsis
if [ "${1:-}" = "synopsis" ]; then
  synopsis
  exit 0
fi

# Help
if [[ "${1:-}" =~ -h|--help|help ]]; then
  doc::help synopsis
  exit 0
fi

# Args parsing
COMMIT_MESSAGE=""
MESSAGE_EDIT=false
RECURSE=true
ORIGINAL_ARGS=("$@")
while [[ $# -gt 0 ]]; do
  case "$1" in
    -e | --edit)
      MESSAGE_EDIT=true
      ;;
    -nr | --no-recurse)
      RECURSE=false
      ;;
    *)
      COMMIT_MESSAGE=${1}
      shift
      break
      ;;
  esac
  shift
done

# First submodules
# If not in a submodule (in a submodule .git is a file)
# Otherwise the commit is only for the submodule
if [ $RECURSE == true ] && [ ! -f .git ]; then

  # script dir is mandatory because we may call the next version
  # and the git-xxxx command in the PATH env var is generally the actual version
  CMD="$SCRIPT_DIR/$(basename "$0")"
  # Quote the arguments otherwise you get space in message
  for ORIGINAL_ARG in "${ORIGINAL_ARGS[@]}"; do
    CMD+=" \"$ORIGINAL_ARG\""
  done
  if ! git submodule foreach "$CMD"; then
    echo::err "Error when executing $(basename "$0") to a submodule. Command: $CMD"
    exit 1
  fi

fi

# Nothing to commit but push
FILES_TO_COMMIT=$(git status --short | wc -l)
if [ "$FILES_TO_COMMIT" == "0" ]; then
  echo::warn "Nothing to commit"
  if git::is_dirty_commit; then
    echo::warn "Dirty commit: pushing"
    git push
  fi
  exit
fi
echo::info "Found $FILES_TO_COMMIT objects to commit"
# Commit Message
if [ "$COMMIT_MESSAGE" = "" ]; then
  COMMIT_MESSAGE=$(git::get_auto_commit_message)
  echo::info "DIRECTORY_NAME - Commit message generated: $COMMIT_MESSAGE"
fi

# Add the files
# (re-normalize below does not add any file into the index)
git add -A

# `--renormalize` to correct the EOL in the working tree
# You get an error on Delete file and we need to take the last element
# Example of output:
#  M README.md
# D docs/lib/bashlib-crypto.md
#RM lib/bashlib-function.sh -> lib/bashlib-bash.sh
#?? docs/lib/bashlib-bash.md
# We read line by line to be able to hand
# jinja file name such as {% if package_manager == 'maven' %}.mvn{% endif %}/wrapper/maven-wrapper.properties
GIT_ROOT="$(git::get_root_directory)"
git diff --cached --name-only --diff-filter=d | while read -r MODIFIED_FILE; do
  # file may be ignored
  MODIFIED_FILE_PATH="$GIT_ROOT/$MODIFIED_FILE"
  if ! git add --renormalize "$MODIFIED_FILE_PATH"; then
    echo::warn "Error on renormalization of the file $MODIFIED_FILE_BASHLIB_LIBRARY_PATH"
    exit 1
  fi
done

# Auto Pull
# Most of the time, pull can be in auto-mode (ie stash, pull, pop)
# Even if we check it at commit time, it's still handy to have it automatically
#
# Most of the time, the other script that needs to commit does not integrate git-commit
# as they prefer do the preparation before and avoid the hooks at commit
#
# Is there an upstream to pull from
CURRENT_BRANCH_UPSTREAM=$(git::get_current_upstream_branch 2> /dev/null)
if [ "$CURRENT_BRANCH_UPSTREAM" != "" ]; then
  # Check if there is commit to integrate
  # `Updates were rejected because the tip of your current branch is behind`
  # ! [rejected]        master -> master (non-fast-forward)
  #error: failed to push some refs to 'https://user:xxxx@github.com/orga/project'
  #hint: Updates were rejected because the tip of your current branch is behind
  #hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
  #hint: before pushing again.
  #hint: See the 'Note about fast-forwards' in 'git push --help' for details.
  git fetch
  # rev-list provides the ability to build and traverse commit ancestry graphs.
  UPSTREAM_COMMIT_TO_MERGE=$(git::get_commits_behind_of_upstream)
  if [ "$UPSTREAM_COMMIT_TO_MERGE" != 0 ]; then
    echo::warn "$UPSTREAM_COMMIT_TO_MERGE Upstream Commits has not been integrated"
    git-pull
  fi
fi

echo::info "Committing $FILES_TO_COMMIT files"
# We can't use echo::eval because the message may be on multiple lines
# Note: multiline is possible with
# * multiple -m: git commit -m "First line" -m "Second line" --edit
# * or a file: git commit -F message.txt --edit
COMMIT_ARGS=(commit -v -m "$COMMIT_MESSAGE")
if [ $MESSAGE_EDIT == true ]; then
  COMMIT_ARGS+=(--edit)
fi
git "${COMMIT_ARGS[@]}"

# Spacing in case of submodule execution
if [ $RECURSE == true ]; then
  # Spacing
  echo ""
fi

if [ "$CURRENT_BRANCH_UPSTREAM" != "" ]; then
  git push
  exit
fi

# No upstream yet
IFS=" " read -r -a remotes <<< "$(git remote)"
if [ ${#remotes[@]} -ne 1 ]; then
  echo::warn "The repository has ${#remotes[@]} remotes, we can't set an upstream"
  echo::warn "Add a remote with"
  echo::warn ""
  echo::warn "   git remote add origin git@hosting.com:namespace/name.git"
  echo::warn "or"
  echo::warn "   git remote add origin https://hosting.com:namespace/name.git"
  echo::warn ""
  exit 1
fi
echo::warn "Adding an upstream on the push"
echo::eval "git push -u ${remotes[0]} $(git::get_current_branch)"
