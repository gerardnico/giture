#!/bin/bash

set -Eeuo pipefail

# Bash lib library path detection
if [ "${BASHLIB_PATH:-}" == "" ]; then
  SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"
  # This is also a valid path for brew
  BASHLIB_PATH="$SCRIPT_DIR/../lib"
fi
export PATH="$BASHLIB_PATH:$PATH"

# shellcheck source=../..//bash-lib/lib/bashlib-error.sh
source "bashlib-error.sh"
error::set_trap
# shellcheck source=../..//bash-lib/lib/bashlib-doc.sh
source "bashlib-doc.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-echo.sh
source "bashlib-echo.sh"

function synopsis() {

  cat << EOF
List hosted repositories

\`\`\`bash
$(basename "$0") git_hosting_service [xxx]
\`\`\`

where:

* git_hosting_service         - the git hosting name to read from (github, gogs, ...)
* --silent                    - a boolean option that will output only the API_REPOS
* --jq-raw-output             - a boolean option that will not output the output as json
* --jq-expression='xxxx'      - the jq expression to parse the JSON API response
* --report=value              - the name of a preconfigured report where the value may be:
                                 * ls       - the repo fullname separated by the IFS character
                                 * asis     - the full json
                                 * csv      - a csv
* --filter-max-repo-count='x' - the maximum number of repositories to retrieve
* --help                      - this help

EOF

}

# Doc Synopsis
if [ "${1:-}" = "synopsis" ]; then
  synopsis
  exit 0
fi

# Help
if [[ "${1:-}" =~ -h|--help|help ]]; then
  doc::help synopsis
  exit 0
fi

GIT_HOSTING=""
# Report are default value for JQ expression
REPORT=""
# The default Jq args are platform dependent
JQ_EXPRESSION=""
JQ_RAW_OUTPUT_OPTION=""

args=$(getopt -l "jq-expression:,filter-max-repo-count:,jq-raw-output,jq-raw,help,report:" -o "r:h" -- "$@")
eval set -- "$args"
# The maximum of repo to retrieved
FILTER_MAX_REPO_COUNT=""
# This for loop should have no echo
# Why? We use this function to get the list of repo to handle
# We therefore need the raw output without any echo
while [[ $# -gt 0 ]]; do
  case "$1" in
    "--jq-expression")
      shift
      JQ_EXPRESSION="$1"
      shift
      ;;
    "--filter-max-repo-count")
      shift
      FILTER_MAX_REPO_COUNT="$1"
      shift
      ;;
    "--jq-raw-output" | "--jq-raw")
      JQ_RAW_OUTPUT_OPTION="--raw-output"
      shift
      ;;
    "--report" | "-r")
      shift
      REPORT="$1"
      shift
      ;;
    "--help" | "-h")
      help_list
      exit
      ;;
    "--")
      # The arg separator
      shift
      ;;
    *)
      if [ "$GIT_HOSTING" == "" ]; then
        # ,, for lowercase
        GIT_HOSTING="${1,,}"
        shift
        continue
      fi

      echo::err "Too much argument found: list except only one argument, the registry. ($1) is the second argument"
      exit 1

      ;;
  esac
done

if [ "$GIT_HOSTING" = "" ]; then
  help_list
  echo::err "The git hosting service name is mandatory"
  exit 1
fi

eval "$(git-hosting-env "$GIT_HOSTING")" || error::exit $?

# Report
# Report are default values
if [ "${REPORT}" == "" ]; then
  REPORT="default"
  echo::info "No Report found, set to: $REPORT"
else
  echo::info "Report: $REPORT"
fi

case ${GIT_HOSTING} in
  gogs)

    # Auth Token
    if [ -z "${GIT_TOKEN+x}" ]; then
      echo::err "Git Token is mandatory to list repo for $GIT_HOSTING"
      exit 1
    fi

    case ${REPORT} in
      "ls")
        JQ_EXPRESSION_REPORT="map(.full_name) | join(\"$IFS\")"
        JQ_RAW_OUTPUT_OPTION="--raw-output"
        ;;
      "asis")
        JQ_EXPRESSION_REPORT='.'
        JQ_RAW_OUTPUT_REPORT_OPTION=""
        ;;
      "default")
        JQ_EXPRESSION_REPORT='[.[] | .full_name]'
        JQ_RAW_OUTPUT_REPORT_OPTION=""
        ;;
      "csv")
        JQ_EXPRESSION_REPORT='["full_name", "fork"], (.[] | [.full_name, .fork]) | @csv'
        JQ_RAW_OUTPUT_OPTION="--raw-output"
        ;;
      *)
        echo::err "The report ($REPORT) is unknown"
        exit 1
        ;;
    esac

    # Jq arguments
    if [ "${JQ_EXPRESSION}" == "" ]; then
      JQ_EXPRESSION=${JQ_EXPRESSION_REPORT}
    fi
    echo::info "Jq Expression: $JQ_EXPRESSION"
    if [ "${JQ_RAW_OUTPUT_OPTION}" == "" ]; then
      JQ_RAW_OUTPUT_OPTION=${JQ_RAW_OUTPUT_REPORT_OPTION}
    fi
    echo::info "Jq Raw Output Option: $JQ_RAW_OUTPUT_OPTION"

    # URL AI
    URL_API="https://$GIT_DOMAIN/api/v1/user/repos"
    echo::info "Requesting $URL_API"

    # Execute
    echo ""
    # $JQ_RAW_OUTPUT_OPTION should not be quoted because jq does not accept empty string argument
    # shellcheck disable=SC2086
    curl -sS -H "Authorization: token $GIT_TOKEN" "$URL_API" | jq $JQ_RAW_OUTPUT_OPTION "${JQ_EXPRESSION}"
    echo ""
    ;;
  github)

    # Auth Token
    if [ -z "${GIT_TOKEN+x}" ]; then
      echo::err "Git Token env (GIT_TOKEN) is mandatory to list repo for $GIT_HOSTING"
      exit 1
    fi

    case ${REPORT} in
      "ls")
        JQ_EXPRESSION_REPORT="map(.full_name) | join(\"$IFS\")"
        JQ_RAW_OUTPUT_OPTION="--raw-output"
        ;;
      "asis")
        JQ_EXPRESSION_REPORT='.'
        JQ_RAW_OUTPUT_REPORT_OPTION=""
        ;;
      "default")
        JQ_EXPRESSION_REPORT='[.[] | .full_name]'
        JQ_RAW_OUTPUT_REPORT_OPTION=""
        ;;
      "csv")
        JQ_EXPRESSION_REPORT='["full_name", "fork", "clone_url"], (.[] | [.full_name, .fork, .clone_url]) | @csv'
        JQ_RAW_OUTPUT_OPTION="--raw-output"
        ;;
      *)
        echo::err "The report ($REPORT) is unknown"
        exit 1
        ;;
    esac

    # Jq arguments
    if [ "${JQ_EXPRESSION}" == "" ]; then
      JQ_EXPRESSION=${JQ_EXPRESSION_REPORT}
    fi
    echo::info "Jq Expression: $JQ_EXPRESSION"
    if [ "${JQ_RAW_OUTPUT_OPTION}" == "" ]; then
      JQ_RAW_OUTPUT_OPTION=${JQ_RAW_OUTPUT_REPORT_OPTION}
    fi
    echo::info "Jq Raw Output Option: $JQ_RAW_OUTPUT_OPTION"

    # URL API: repo for the authenticated user
    # Doc: https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#list-repositories-for-the-authenticated-user
    URL_API="https://api.github.com/user/repos"
    REPO_BY_PAGE=100
    if [ "$FILTER_MAX_REPO_COUNT" != "" ] && [ "$FILTER_MAX_REPO_COUNT" -lt "$REPO_BY_PAGE" ]; then
      REPO_BY_PAGE=$FILTER_MAX_REPO_COUNT
    fi
    ACTUAL_PAGE=1
    TOTAL_COUNT=0
    TOTAL_REPOS='[]'
    while true; do

      REQUEST_URL="$URL_API?per_page=$REPO_BY_PAGE&page=$ACTUAL_PAGE"
      echo::info "$ACTUAL_PAGE - Requesting $REPO_BY_PAGE repo ($REQUEST_URL)"

      ACTUAL_REPOS=$(curl -sS -H "Authorization: token $GIT_TOKEN" "$REQUEST_URL")
      TOTAL_REPOS=$(jq -s '.[0] + .[1]' <(echo "$TOTAL_REPOS") <(echo "$ACTUAL_REPOS"))

      # Count the number of objects
      COUNT=$(echo "$ACTUAL_REPOS" | jq ". | length")
      # Add the COUNT to the total COUNT
      TOTAL_COUNT=$((TOTAL_COUNT + COUNT))

      # Break on last page
      if [ "$COUNT" -lt "$REPO_BY_PAGE" ]; then
        echo::info "Retrieved $TOTAL_COUNT repositories"
        break
      fi

      # Break on max count
      if [ "$FILTER_MAX_REPO_COUNT" != "" ] && [ "$TOTAL_COUNT" -ge "$FILTER_MAX_REPO_COUNT" ]; then
        echo::info "Max total count repositories ($TOTAL_COUNT) reached"
        break
      fi

      ACTUAL_PAGE=$((ACTUAL_PAGE + 1))

    done

    echo::info ""
    # $JQ_RAW_OUTPUT_OPTION should not be quoted because jq does not accept empty string argument
    # shellcheck disable=SC2086
    echo "$TOTAL_REPOS" | jq $JQ_RAW_OUTPUT_OPTION "${JQ_EXPRESSION}"

    ;;
  *)
    echo::err "The git platform $GIT_PLATFORM is not yet implemented"
    exit 1
    ;;
esac
