#!/usr/bin/env bash
# A improved version of `last = log -1 HEAD`

set -Eeuo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"

# Bash lib library path detection
if [ "${BASHLIB_PATH:-}" == "" ]; then
  # This is also a valid path for brew
  BASHLIB_PATH="$SCRIPT_DIR/../lib"
fi
export PATH="$BASHLIB_PATH:$PATH"

# shellcheck source=../..//bash-lib/lib/bashlib-error.sh
source "bashlib-error.sh"
error::set_trap
# shellcheck source=../..//bash-lib/lib/bashlib-doc.sh
source "bashlib-doc.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-string.sh
source "bashlib-string.sh"

function synopsis() {

  cat << EOF
\`\`\`bash
$(basename "$0") [Options]
\`\`\`

  * \`-nr\` or \`--no-recurse\` to not recurse in submodule
EOF

}

RECURSE=true
ORIGINAL_ARGS=("$@")
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help | help)
      # Help
      doc::help synopsis
      exit 0
      ;;
    synopsis)
      # Doc Synopsis
      synopsis
      exit 0
      ;;
    -nr | --no-recurse)
      RECURSE=false
      ;;
  esac
  shift
done

# First submodules
# If not in a submodule (in a submodule .git is a file)
# Otherwise the commit is only for the submodule
if [ $RECURSE == true ] && [ ! -f .git ]; then

  # script dir is mandatory because we may call the next version
  # and the git-xxxx command in the PATH env var is generally the actual version
  CMD="$SCRIPT_DIR/$(basename "$0")"
  # Quote the arguments otherwise you get space in message
  for ORIGINAL_ARG in "${ORIGINAL_ARGS[@]}"; do
    CMD+=" \"$ORIGINAL_ARG\""
  done
  if ! git submodule foreach "$CMD"; then
    echo::err "Error when executing $(basename "$0") to a submodule. Command: $CMD"
    exit 1
  fi

fi

# Status of the actual repo
if [ ! -f .git ]; then
  echo "Entering main repo"
fi

# https://git-scm.com/docs/git-config#Documentation/git-config.txt-color
# https://git-scm.com/docs/git-log#_pretty_formats
# https://git-scm.com/docs/git-log#_diff_formatting

HEAD_COLOR="green"
colored_header() {
  echo "%C($HEAD_COLOR)$*%Creset"
}
padded_header() {
  #string::set_color "$HEAD_COLOR" "$*"
  # The %<(N) syntax format only the next placeholder as N columns wide
  # Therefore we need to use printf to right pad the header
  PADDED_HEAD=$(printf '%-15s' "$*")
  colored_header "$PADDED_HEAD"
}

COMMIT_HASH="$(padded_header 'Commit'): %H"
AUTHOR="$(padded_header 'Author'): %an <%ae>"
AUTHOR_DATE="$(padded_header 'AuthorDate'): %ai"
COMMITTER="$(padded_header 'Committer'): %cn <%ce>"
COMMITTER_DATE="$(padded_header 'Committer Date'): %ci"
BRANCH="$(padded_header 'Branch'): %D%n"
SUBJECT="$(padded_header 'Subject'): %s" # s means subject,
BODY="$(colored_header 'Body'):%n%b"     # b = body
FILES="$(colored_header 'Files'):"

git show --name-status \
  --pretty=format:"${COMMIT_HASH}%n${AUTHOR}%n${AUTHOR_DATE}%n${COMMITTER}%n${COMMITTER_DATE}%n${BRANCH}%n${SUBJECT}%n${BODY}%n${FILES}" \
  HEAD

if [ $RECURSE == true ]; then
  # Spacing
  echo ""
fi
