#!/usr/bin/env bash
# See md file

set -Eeuo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"

# Bash lib library path detection
if [ "${BASHLIB_PATH:-}" == "" ]; then
  # This is also a valid path for brew
  BASHLIB_PATH="$SCRIPT_DIR/../lib"
fi
export PATH="$BASHLIB_PATH:$PATH"

# shellcheck source=../bash-lib/lib/bashlib-error.sh
source "bashlib-error.sh"
error::set_trap
# shellcheck source=../bash-lib/lib/bashlib-doc.sh
source "bashlib-doc.sh"

function synopsis() {

  cat << EOF
Short Git status that also works on submodule
\`\`\`bash
$(basename "$0")
\`\`\`
EOF

}

# Doc Synopsis
if [ "${1:-}" = "synopsis" ]; then
  synopsis
  exit 0
fi

# Help
if [[ "${1:-}" =~ -h|--help|help ]]; then
  doc::help synopsis
  exit 0
fi

# git ls-files wrapper
# difficult to get the status
function git_working_status() {
  modified=$(git ls-files -m)
  if [[ -n $modified ]]; then
    echo -e "Modified not staged:\n$modified"
  fi
  deleted=$(git ls-files -d)
  if [[ -n $deleted ]]; then
    echo ""
    echo -e "Deleted:\n$deleted"
  fi
  untracked=$(git ls-files -o --exclude-standard)
  if [[ -n $untracked ]]; then
    echo ""
    echo -e "Not tracked (may be ignored):\n$untracked"
  fi
  if [[ -z $modified && -z $deleted && -z $untracked ]]; then
    echo "No modifications"
  fi
}

# Porcelain script that shows how to parse it
function git_status() {
  # for scripting: git status --porcelain
  # porcelain means give the output in an easy-to-parse format for scripts
  local vPorcelain
  vPorcelain=$(git status --porcelain)
  echo ""
  echo "Git Status:"
  if [[ -z $vPorcelain ]]; then
    echo "  No modifications"
    return
  fi
  # output:
  # for an unstaged file: `status space path`
  # for a staged file: `status space space path`
  echo "$vPorcelain" | while read -r fileStatusLine; do
    fileStatus=${fileStatusLine:0:1} # not yet used
    fileStatusStaged=${fileStatusLine:1:2}
    filePath=${fileStatusLine:2}
    if [ "${fileStatusStaged}" == '  ' ]; then
      stagedOrNot=' (staged)'
      # filePath=${fileStatusLine:3} # not yet used
    else
      stagedOrNot=' (unstaged)'
      # filePath=${fileStatusLine:2} # not yet used
    fi
    echo "$fileStatus $filePath ${stagedOrNot}"
  done

}

# Function below are deprecated for now, we use the standard default format
# git_working_status
# git_status

# First submodule status
# Not in a submodule (.git is a file)
if [ ! -f .git ]; then
  # script dir is mandatory because we may call the next version
  # and git-amend in the path is generally the actual version
  git submodule foreach "$SCRIPT_DIR/git-status"
  # Note there is also
  # git submodule status
fi

# Status of the actual repo
if [ ! -f .git ]; then
  echo "Entering main repo"
fi

BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
echo "Branch: $BRANCH_NAME"

# Nothing to commit feedback if any
FILES_TO_COMMIT=$(git status --short | wc -l)
if [ "$FILES_TO_COMMIT" == "0" ]; then
  echo::warn "Nothing to commit"
fi

# This command do not output anything if there is nothing (even not a end of line)
git status --short

# Spacing between module and repo
echo ""
